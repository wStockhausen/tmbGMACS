---
title: "Model Dimensions Vignette"
author: "William Stockhausen"
crossref: 
  fig-title: Figuure
  tbl-title: Table
comment: "#>"
collapse: true
toc: true
format: 
  html: 
    html-math-method: mathjax
tbl-cap-location: top
fig-cap-location: bottom
prefer-html: true
keep-md: true
keep-yaml: true
vignette: >
  %\VignetteIndexEntry{Model dimensions}
  %\VignetteEngine{tmbGMACS::quarto}
  %\VignetteEncoding{UTF-8}
---

<!--NOTE: for scalar variables,    use: *var*   (italics)  
          for vectors/matrices,etc use: ***V*** (bold-italics) 
          for functions            use: **fcn** (bold) 
          for verbatim code        use: `code` 
-->

```{r setup,echo=FALSE}
  library(tmbGMACS);
```

## Model dimensions 

Model dimensions consist of year (*y*), season (*s*), and a set of categories ({*c*}) into which the population is divided (e.g., sex and size). Levels within a given population category can be nested within another category (e.g., different size classes might be defined for males and females if they exhibited substantially different growth patterns). For a given year, population 
abundance is integrated across seasons within the year and different processes can occur in different seasons. 

Dimensions are defined using the function **createSparseDimsMap**. As an example (@tbl-Ex1), the following creates a set of dimensions encompassing year (*y*), season(*s*), sex (*x*), and size (*z*), with different size classes for males and females. Note that the "dimension name(s)" are added to the vector or list defining the levels as an attribute `dmnms`.

```{r ex1}
library(tmbGMACS);
#> Create the individual dimensions as vectors or lists (for nested dimensions)
#> --assign the attribute "dmnms", the dimension name(s) (plural if nested)
#> ----model years
vYs = 2001:2005;                  attr(vYs,"dmnms")<-"y";
#> ----model seasons
vSs = c("fall","spring");         attr(vSs,"dmnms")<-"s";
#> ----model sexes
vXs = c("MALE","FEMALE");         attr(vXs,"dmnms")<-"x";
#> ----model sizes, nested with sexes
vZs = list(  MALE=seq(40,60,5),
           FEMALE=seq(25,50,5));  attr(vZs,"dmnms")<-c("x","z");
#>--create the dimensions "map"
dms = tmbGMACS::createSparseDimsMap(y=vYs,s=vSs,x=vXs,z=vZs);
```

```{r}
#| label: tbl-Ex1
#| tbl-cap: "Example dimensions map."
#| eval: !expr '(require(kableExtra))'
#| echo: false
dms |> kableExtra::kbl(booktabs=TRUE,longtable=TRUE);
```

A dimensions map has non-standard attributes: `dmnms`, `dmlvs`, and `dmlns`: 

  - `dmnms` is a character vector with the dimension names.
  - `dmlvs` is a character vector with the unique levels for each dimension.
  - `dmlns` is a named integer vector with the length (number of unique levels) of each dimension.
  
The first column in the model dimensions map is simply the row number associated with the combination of 
unique dimension levels the row reflects. It also provides the index into the population abundance 
vector for that combination of dimensions (and thus allows the extraction of the associated dimension levels given 
the index value).

Most model quantities are represented as vectors, and thus have associated dimensions maps in order to be able to identify the dimension levels associated with each index value.

## Aggregating over model dimensions

Data fit in gmacs typically represent quantities aggregated over some combination of population categories, so it is necessary to determine the mappping from model indices to data indices. The function **createAggregatorMap*** provides the required mapping of 1-d indices from one dimensions map to another, as illustrated in the following example (@tbl-Ex2) using the dimensions map `dms` from the previous example:

```{r ex2}
#> Example of how to create an aggregator map using "dms" from above
#> to aggregate by year (y) and sex (x) over season (s) and size (z). 
#>    Create dimensions map with only y and x
  aggDims = tmbGMACS::keepDims(dms,keep=c("y","x"));#--keeps only y and x dimensions, recreates 1-d vector index
#>    Create aggregator map from y,x,s,z to y,x
  aggMap  = tmbGMACS::createAggregatorMap(dms,aggDims,keepOrigDims=TRUE);
```

*j* is the vector index for `aggDims`, *i* is the vector index for `dms`.
```{r}
#| label: tbl-Ex2
#| tbl-cap: Example aggregator map (from indices i to indices j).
#| eval: !expr 'require(kableExtra)'
#| echo: false
aggMap |> kableExtra::kbl(booktabs=TRUE,longtable=TRUE);
```
